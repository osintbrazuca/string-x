#!/usr/bin/python
"""
String-X (STRX) - Ferramenta de automatização de comandos

Este módulo é o ponto de entrada principal da ferramenta String-X, uma ferramenta
de automatização rápida e personalizável desenvolvida para auxiliar analistas em
diversas tarefas que dizem respeito à manipulação de strings em linhas de comando.

A ferramenta reconhece fontes de dados, seja por meio do resultado de um cat,
script scan ou request via curl. Os dados coletados da source são tratados como
string e manipulados via parâmetro reservado da ferramenta.

Tipos de módulos suportados:
- output (OUT): Módulos para formatação de saída
- connection (CON): Módulos para estabelecer conexões  
- extractor (EXT): Módulos para extrair dados específicos
- collector (CLC): Módulos para coletar e agregar informações

Author: Cleiton Pinheiro aka MrCl0wn
Email: mrcl0wnlab[@]gmail.com
License: MIT
Version: 0.1
"""

import os
import sys
import signal
import select
from config import setting
from core.command import Command
from core.filelocal import FileLocal
from core.thread_process import ThreadProcess

from core.style_cli import StyleCli, RichArgumentParser, RawDescriptionHelpFormatter
from core.auto_module import AutoModulo


__author__ = "Cleiton Pinheiro aka MrCl0wn"
__maintainer__ = "Cleiton Pinheiro aka MrCl0wn"
__credits__ = ["Cleiton Pinheiro"]
__license__ = "MIT"
__version__ = "0.1"
__email__ = "mrcl0wnlab[@]gmail.com"
__twitter__ = "https://twitter.com/MrCl0wnLab"
__git__ = [
    "https://github.com/MrCl0wnLab",
    "https://github.com/osintbrazuca"
]


def quit_process(signal, frame) -> None:
    """
    Manipula a interrupção do processo por sinal SIGINT (Ctrl+C).
    
    Esta função é chamada quando o usuário pressiona Ctrl+C, permitindo
    uma saída limpa do programa com informações sobre o último arquivo
    de saída e o último valor processado.
    
    Args:
        signal: O sinal recebido
        frame: O frame atual de execução
        
    Returns:
        None
    """
    print("")
    CLI.console.log(f" [!] Saindo...")
    CLI.console.log(f" [!] File output: {setting.LOG_FILE_OUTPUT}")
    CLI.console.log(f" [!] Last value: {CMD.last_value}")
    sys.exit(0)


def stdin_get_list() -> list:
    """
    Obtém uma lista de strings do stdin (entrada padrão).
    
    Esta função verifica se há dados disponíveis no stdin sem bloquear
    a execução do programa. É utilizada para permitir que o programa
    aceite dados via pipe (|) de outros comandos.
    
    Returns:
        list: Lista de strings lidas do stdin, ou None se não houver dados
        
    Raises:
        KeyboardInterrupt: Quando o usuário interrompe a execução
        NameError: Quando há erro de nome de variável
        IOError: Quando há erro de entrada/saída
        
    Reference:
        https://stackoverflow.com/a/3763257
    """
    try:
        if select.select([sys.stdin], [], [], 0.0)[0]:
            stdin_list = sys.stdin.readlines()
            if stdin_list:
                return stdin_list
        else:
            return None
        return None
    except KeyboardInterrupt:
        CLI.console.print_exception(max_frames=3)
    except NameError:
        CLI.console.print_exception(max_frames=3)
    except IOError:
        CLI.console.print_exception(max_frames=3)


def open_file(filename: str) -> list[str]:
    """
    Abre um arquivo e retorna seu conteúdo como lista de strings.
    
    Args:
        filename (str): Caminho para o arquivo a ser aberto
        
    Returns:
        list[str]: Lista com as linhas do arquivo ou None se houver erro
    """
    if filename:
        try:
            txt_line, _ = FILE.open_file(filename, 'r')
            if txt_line:
                return txt_line
        except Exception:
            pass


def main(target_str_list: list, template_str: str) -> None:
    """
    Função principal que executa o processamento das strings de entrada.
    
    Esta função recebe uma lista de strings de entrada e um template de comando,
    e executa o processamento usando threads para melhor performance.
    
    Args:
        target_str_list (list): Lista de strings para processar
        template_str (str): Template de comando para executar
        
    Returns:
        None
        
    Raises:
        BrokenPipeError: Quando há erro de pipe quebrado
    """
    if target_str_list and template_str:
        try:
            if list is type(target_str_list):
                try:
                    THREAD.exec_thread(
                        function_name=CMD.command_template,
                        command_str=template_str,
                        target_list=target_str_list,
                        argparse=ARGS,
                    )
                except Exception:
                    CLI.console.print_exception(max_frames=3)
        except BrokenPipeError:
            CLI.console.print_exception(max_frames=3)


if __name__ == '__main__':
    signal.signal(signal.SIGINT, quit_process)
    CLI = StyleCli()
    FILE = FileLocal()
    THREAD = ThreadProcess()
    CMD = Command()

    try:
        parser = RichArgumentParser(
            prog="strx",
            formatter_class=lambda prog: RawDescriptionHelpFormatter(
                prog, max_help_position=60,
                indent_increment=13),
            description=setting.BANNER_HELP
        )
        parser.add_argument('-list', '-l', metavar="file", help="Arquivo com strings para execução", default=stdin_get_list())
        parser.add_argument('-str', '-st', metavar="cmd", help="String template de comando", default=None, required=True)
        parser.add_argument('-out', '-o', metavar="file", help="Arquivo output de valores da execução shell", default=setting.LOG_FILE_OUTPUT)
        parser.add_argument('-pipe', '-p', metavar="cmd", help="Comando que será executado depois de um pipe |", default=None)
        parser.add_argument('-verbose', '-v', help="Modo verboso", action='store_true', default=False)
        parser.add_argument('-thread', '-t', metavar=f"<{setting.THREAD_MAX}>", help="Quantidade de threads", default=setting.THREAD_MAX)
        parser.add_argument('-pf', help="Mostrar resultados da execução de função, ignora shell", action='store_true', default=False)
        parser.add_argument('-of', help="Habilitar output de valores da execução de função", action='store_true', default=False)
        parser.add_argument('-filter', '-f', metavar="value", help="Valor para filtrar strings para execução", default=None, required=False)
        parser.add_argument('-sleep', metavar="<5>", help="Segundos de delay entre threads", default=None, required=False)
        parser.add_argument('-module', metavar="<type:module>", help="Selectionar o tipo e module", default=str(), required=False)
        parser.add_argument('-pm', help="Mostrar somente resultados de execução do module", action='store_true', default=False)
        
        ARGS = parser.parse_args() 

        if ARGS.thread:
            THREAD.max_thread = int(ARGS.thread)
        
        if ARGS.list:
            target_list = open_file(ARGS.list) if os.path.isfile(str(ARGS.list)) else ARGS.list
        else:
            CLI.console.print(f"{setting.BANNER_HELP}\n")
            exit(parser.parse_args('-h'))


        CMD.file_output = ARGS.out
        CMD.file_last_output = f'./{setting.LOG_DIRECTORY}/{setting.LOG_FILE_LAST}'
        CMD.verbose = ARGS.verbose

        main(
            target_str_list=target_list,
            template_str=ARGS.str
        )
    except KeyboardInterrupt:
        pass
    except SystemError:
        CLI.console.print_exception(max_frames=3)
    except ModuleNotFoundError:
        CLI.console.print_exception(max_frames=3)
